# Lazy execution

```{r}
#| label: load-packages-lazy-execution
#| code-fold: true
#| message: false
#| warning: false
#| results: 'hide'
library(polars)
library(arrow)
library(fakir)
library(tictoc)

# Creation the "Datasets" folder
dir.create(normalizePath("Datasets"))

# Creation of large example csv dataset
write.csv(
  x = fake_ticket_client(vol = 100000),
  file = normalizePath("Datasets/fakir_file.csv"))

# Creation of large example parquet dataset
write_parquet(
  x = fake_ticket_client(vol = 100000),
  sink = normalizePath("Datasets/fakir_file.parquet"))
```

::: {.callout-note}
This chapter only deals with the **lazy execution** of Polars. It does not include a comparison with R base, dplyr and data.table
:::

## Introduction to lazy mode

Polars supports two modes of operation: **lazy** and **eager**.

Let's start this chapter by citing the official documentation:

> In the eager API the query is executed immediately while in the lazy API the query is only evaluated once it is 'needed'. Deferring the execution to the last minute can have significant performance advantages that is why the Lazy API is preferred in most cases. Delaying execution until the last possible moment allows Polars to apply automatic optimization to every query.

As you can see, with **lazy mode**, you give the engine the chance to analyse what you want to do in order to propose optimal execution (for both reading and transforming datasets). **Lazy evaluation** is a fairly common method of improving processing speed and is used by [Spark](https://spark.apache.org/docs/latest/index.html), among others.

So far in this book, we have only used the **eager mode** but fortunately all the syntax we've seen applies to **lazy mode** too. Whatever mode is used, queries will be executed transparently for users.

### Creation of a `LazyFrame` with lazy()

To convert a `DataFrame` to a `LazyFrame` we can use the `lazy()` contructor.

```{r}
#| label: creation-lazyFrame
pl$DataFrame(iris)$lazy()
```
We are no longer working on a `DataFrame` but on a `LazyFrame`.  

### First query passed on `LazyFrame`

Let's look at what happens when we request this `LazyFrame`:

```{r}
#| label: first-query-lazy
myquery <- pl$DataFrame(iris)$lazy()$filter(
  pl$col("Species") == "setosa"
)$select(
  pl$col(c("Species", "Petal.Length"))
)
myquery
```
This way, we can display the **naive plan** but as indicated in the console, we can use the `describe_optimized_plan()` method to see the **optimized plan**.

```{r}
#| label: optimized-query-lazy
myquery$describe_optimized_plan()
```

This example shows a simple but surprisingly effective element of query optimisation: **projection**. Changing the order in which our subset operations occur - in this case, the subset on columns first - reduces the memory overhead of the global query.

### Execute the plan

To actually execute the plan, we just need to invoke the **collect()** method. 

```{r}
#| label: collect-query-lazy
myquery$collect()
```

## `Lazy` vs `eager` mode comparison

```{r}
#| label: eager-query-steps
df <- pl$read_csv("examples/iris.csv")
df_small = df$filter(pl$col("Petal.Length") > 5)
df_agg = df_small$groupby("Species")$agg(pl$col("Petal.Width")$median())
df_agg
```

In this example we use the **eager API** to:

- Read the iris dataset.
- Filter the dataset based on Petal.Length
- Calculate the median of the Petal.Width per Species

**Every step is executed immediately returning the intermediate results**. This can be very **wastefull** as we might do work or load extra data that is not being used.  
If we instead used the **lazy API** and waited on execution untill all the steps are defined then the query planner could perform various optimizations. In this case:

- `Predicate pushdown`: Apply filters as early as possible while reading the dataset, thus only reading rows with sepal length greater than 5.
- `Projection pushdown`: Select only the columns that are needed while reading the dataset, thus removing the need to load additional columns

::: callout-tip
To consult the list of **optimisations** made by `Polars` on queries in **lazy mode**, see [this page](https://pola-rs.github.io/polars-book/user-guide/lazy/optimizations/)..
:::

Here is the equivalent code using the lazy API. At the end of the query, don't forget to use the `collect()` method to inform Polars that you want to execute it.

```{r}
#| label: lazy-query-steps
pl$read_csv("examples/iris.csv", lazy = TRUE)$filter(
  pl$col("Petal.Length") > 5)$groupby(
    "Species")$agg(pl$col("Petal.Width")$median())$collect() # <- don't forget collect() here!
```

::: {.callout-important}
Use **lazy execution** will signficantly lower the load on memory & CPU thus allowing you to fit bigger datasets in memory and process faster.
:::

The next part will demonstrate this time saving. ðŸ‘‡

## `Lazy` vs `eager` mode : fight !

For this fight, we're going to use a fake dataset created with the {fakir} package. The code for creating this dataset is available at the beginning of this document.


```{r}
tic()
#| label: fight-eager_read_csv
pl$read_csv("Datasets/fakir_file.csv", infer_schema_length=0)$ 
  select(
    pl$col(c("region","departement","priority")) 
  )$
  filter(
    pl$col("region") == "Bretagne")
toc()
```
  
```{r}
#| label: fight-lazy_csv_reader
tic()
pl$lazy_csv_reader("Datasets/fakir_file.csv")$ 
  select(
    pl$col(c("region","departement","priority")) 
  )$
  filter(
    pl$col("region") == "Bretagne")$
  collect()
toc()
```




::: {.callout-note}
The `read_parquet()` method has not been implemented in the R Polars package, but for this fight we will use `arrow::read_parquet()`, which will compete with `polars::scan_parquet()`.
:::

```{r}
#| label: fight-eager-read-parquet
#| message: false
tic()
eager_result <- arrow::read_parquet("Datasets/fakir_file.parquet") %>% 
  filter(region == "Bretagne") %>% 
  group_by(departement,priority) %>% 
  summarise(mymean=mean(age)) %>% 
  arrange(departement)
toc()
```

```{r}
#| label: fight-lazy-scan-parquet
tic()
lazy_result <- scan_parquet("Datasets/fakir_file.parquet")$
  filter( 
    pl$col("region") == "Bretagne")$
  groupby(c("departement","priority"))$
  agg(
    pl$col(c("age"))$mean()
)$collect()
toc()
```
