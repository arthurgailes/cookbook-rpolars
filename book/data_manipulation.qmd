# Data manipulation

```{r}
#| label: load-packages-data-manipulation
#| code-fold: true
#| message: false
#| warning: false
#| results: 'hide'
library(polars)
library(dplyr)
library(data.table)
library(arrow)
iris_dt <- as.data.table(iris)
```

## Series and vectors

In polars objects, `Series` object are like R `vectors`.  
To create a Polars Series from scratch:

::: {.panel-tabset}
## polars

```{r}
#| label: series-polars
mynumbers_serie <- pl$Series(1:3)
myletters_serie <- pl$Series(c("a","b","c"))
```

## R base

```{r}
#| label: vectors-rbase
mynumbers_vector <- 1:3
myletters_vector <- c("a","b","c")
```

:::

## DataFrame and data.frame

In polars objects, `DataFrame` object are like R `vectors` and close to a `tibble` and a `data.table` object.  
To create a Polars DataFrame from scratch:

::: {.panel-tabset}
## polars

```{r}
#| label: dataframe-polars
# Creation of a DataFrame object with Series
mydf <- pl$DataFrame(
  col1 = mynumbers_serie,
  col2 = myletters_serie
)
# Creation of a DataFrame object with Series and vectors
pl$DataFrame(
  col1 = mynumbers_serie,
  col2 = myletters_vector
)
```

## R base

```{r}
#| label: dataframe-rbase
data.frame(
  col1 = mynumbers_vector,
  col2 = myletters_vector
)
```

## dplyr

```{r}
#| label: tibble-dplyr
tibble(
  col1 = mynumbers_vector,
  col2 = myletters_vector
)
```

## data.table

```{r}
#| label: tibble-datatable
data.table(
  col1 = mynumbers_vector,
  col2 = myletters_vector
)
```

:::

## Manipulation of Series and DataFrames with R standard functions

`Series` and `DataFrames` can be manipulated **with a lot of standard R functions**.  
Some examples with `Series`:

```{r}
#| label: series-manipulation-standard
sum(mynumbers_serie)
paste(myletters_serie,collapse = "")
```

Some examples with `DataFrames`:

```{r}
#| label: dataframe-manipulation-standard
names(mydf)
ncol(mydf)
```

## Methods

The added value of Polars consists in the `methods`. Those powerful methods are accessed using the `$` operator.  

- For `Series`, see [this section](#list-of-methods-to-apply-to-series) for the methods available in {polars}.
- For `DataFrames`, see [this section](#list-of-methods-to-apply-to-dataframe) for the methods available in {polars}.

Some examples with `Series`:

```{r}
#| label: series-manipulation-method
# To get a sum
mynumbers_serie$sum()
# To sort in descending order
mynumbers_serie$sort(reverse = TRUE)
```

Some examples with `DataFrame`:

```{r}
#| label: dataframe-manipulation-method
# To get a character vector of column names
mydf$columns
# To get dimensions of DataFrame
mydf$shape
# We can mix standard R functions and methods
length(mydf$columns)
```

Polars includes a very useful chaining method in data manipulation operations. From this point of view, Polars is more like dplyr and data.table.
This is how the chaining method is defined in the official documentation:

> In polars our method chaining syntax takes the form `object$m1()$m2()`, where object is our data `object`, and `m1()` and `m2()` are appropriate methods, like subsetting or aggregation expressions.

Let's see an example with the iris dataset:

::: {.panel-tabset}
## polars

```{r}
#| label: chaining-polars
pl$DataFrame(iris)$groupby(
  "Species")$median()  
```

## R base

```{r}
#| label: aggregate-rbase
aggregate(. ~ Species, iris, median)
```

## dplyr

```{r}
#| label: chaining-dplyr
iris |>
  group_by(Species) |>
  summarise(across(everything(),median))
```

## data.table

```{r}
#| label: chaining-datatable
iris_dt[, lapply(.SD, median), by = Species]
```

:::

::: {.callout-tip}
In the Polars code used above, you will notice that we have introduced line breaks. We could have written the whole code on the same line but for the sake of readability I prefer to separate the methods used by line breaks.
:::

## Common data manipulation methods

### Conversion between Series/DataFrames and vector/data.frames

#### From vector/data.frames to Series/DataFrames

These conversions have already been seen earlier in this book.

```{r}
#| label: conversion-method
# To convert vector to Polars Series
myvector <- pl$Series(c("a","b","c"))
# To convert data.frames to DataFrames
iris_polars <- pl$DataFrame(iris)
```

#### From Series/DataFrames to vector/data.frames

Here, we can use `to_r()` and `to_data_frame()` methods.

```{r}
#| label: conversion-method
# To convert Polars Series to vector or list
myletters_serie$to_r()
# To convert DataFrames to data.frames
mydf$to_data_frame()
```

### Some initial informations on a DataFrame

Here is a list of instructions that I frequently use to quickly get information about a DataFrame:

```{r}
#| label: informations-methods
# To get column types as strings. 
mydf$dtype_strings()
# To get an estimation of the total allocated size (in Bytes)
mydf$estimated_size()
# To get the first n rows
mydf$head(2)
# To get the dimensions
mydf$shape()
# To get the dimensions
mydf$shape()
```


### Method filter

The `filter()` method is used to filter the rows of a DataFrame. It must be used with the `col()` method which allows to designate the columns on which the filter condition will be applied.

::: {.panel-tabset}
## polars

```{r}
#| label: filter-polars
pl$DataFrame(iris)$filter(
  pl$col("Petal.Length") > 6 & pl$col("Petal.Width") < 2)
```

## R base

```{r}
#| label: filter-rbase
iris[iris$Petal.Length > 6 & iris$Petal.Width < 2,] # here don't forget the comma
```

## dplyr

```{r}
#| label: filter-dplyr
iris |>
  filter(Petal.Length > 6 & Petal.Width < 2) 
```

## data.table

```{r}
#| label: filter-datatable
iris_dt[Petal.Length > 6 & Petal.Width < 2]
```

:::

### Method select

The `select()` method is used to filter the rows of a DataFrame. It must be used with the `col()` method which allows to designate the columns to be selected.

::: {.panel-tabset}
## polars

```{r}
#| label: select-polars
pl$DataFrame(iris)$select(
  pl$col(c("Petal.Length","Petal.Width"))
)$head(3) # display the first 3 lines
```

## R base

```{r}
#| label: select-rbase
iris[1:3,c("Petal.Length","Petal.Width")] 
```

## dplyr

```{r}
#| label: select-dplyr
iris |>
  select(Petal.Length,Petal.Width) |>
  head(3)
```

## data.table

```{r}
#| label: select-datatable
iris_dt[,.(Petal.Length,Petal.Width)]
iris_dt[1:3,]
```

:::

::: {.callout-note}
If you want to obtain a result in an R data.frame, you can simply add the method `to_data_frame()` at the end of the method chaining.
:::

Similar to the dplyr package, the select() method can also be used to modify existing data. However, the result will exclude any columns that were not specified in the expression.

For example, if we want to get in the data.frame iris the `Petal.Length` column rounded without decimals.

```{r}
#| label: select-round-polars
pl$DataFrame(iris)$select(
  pl$col("Petal.Length")$round(decimals = 0)
)$head(3) # display the first 3 lines
```

The problem here is that we would like to keep all the iris columns and not just `Petal.Length`.

Again, let's look at the official documentation:

> To modify or add some columns—whilst preserving all others in the dataset—it is therefore better to use the `with_columns()` method. 

::: {.panel-tabset}
## polars

```{r}
#| label: select-round-polars
pl$DataFrame(iris)$with_columns(
  pl$col("Petal.Length")$round(decimals = 0)
)$head(3) # display the first 3 lines
```

## R base

```{r}
#| label: select-round-rbase
iris$Petal.Length <- round(iris$Petal.Length, digits = 0)
iris[1:3,]
```

## dplyr

```{r}
#| label: select-round-dplyr
data(iris)
iris |>
  mutate(Petal.Length = round(Petal.Length,0)) |>
  head(3)
```

## data.table

```{r}
#| label: select-round-datatable
iris_dt[,Petal.Length := round(Petal.Length, digits = 0)]
iris_dt[1:3,]
```

:::

If you want to add a column to a data.frame, you use the same syntax as above with `with_columns()`. Simply use the `alias()` method to specify the name of the newly created column.

```{r}
#| label: select-round-polars
pl$DataFrame(iris)$with_columns(
  pl$col("Petal.Length")$round(decimals = 0)$alias("Petal.Length.rounded")
)$head(3) # display the first 3 lines
```

### Methods agg and group_by

Another frequently used data manipulation is the aggregation of data by group.
To do this, we indicate in the `group_by()` method which column will be used to group the data.frame. And the `agg()` method which specifies the expression to aggregate.

::: {.panel-tabset}
## polars

```{r}
#| label: agg-polars
pl$DataFrame(iris)$groupby(
  "Species"
)$agg(
  pl$col(c("Petal.Length","Petal.Width"))$sum()
)
```

## R base

```{r}
#| label: aggregate-rbase
aggregate(cbind(Petal.Length, Petal.Width) ~ Species, data = iris, FUN = sum)
```

## dplyr

```{r}
#| label: summarise-dplyr
data(iris)
iris |>
  group_by(Species) |>
  summarise(across(c(Petal.Length, Petal.Width), sum)) 
```

## data.table

```{r}
#| label: summarise-datatable
iris_dt <- as.data.table(iris)
iris_dt[, .(Petal.Length = sum(Petal.Length), Petal.Width = sum(Petal.Width)), by = Species]
```

:::

### Method join

To perform joins, the `join()` method must be used.

::: {.panel-tabset}
## polars

```{r}
#| label: join-polars
# First, creation of colors_species Polars DataFrame
colors_species <- pl$DataFrame(
  Species = c("setosa","versicolor","virginica"),
  Color = c("blue","red","yellow")
)
# Let's join !
pl$DataFrame(iris)$join(
  colors_species,
  on = "Species",
  how = "left"
)
```

## R base

```{r}
#| label: join-rbase
aggregate(cbind(Petal.Length, Petal.Width) ~ Species, data = iris, FUN = sum)
```

## dplyr

```{r}
#| label: join-dplyr
data(iris)
iris |>
  group_by(Species) |>
  summarise(across(c(Petal.Length, Petal.Width), sum)) 
```

## data.table

```{r}
#| label: join-datatable
iris_dt <- as.data.table(iris)
iris_dt[, .(Petal.Length = sum(Petal.Length), Petal.Width = sum(Petal.Width)), by = Species]
```

:::

### Others useful methods

#### On Series

##### Change name of Series 

The `alias()` method is very useful especially in method chaining operation.  
With R base, the syntax is longer.

::: {.panel-tabset}
## polars

```{r}
#| label: change-name-Series
pl$Series(1:3, name = "toto")$alias("titi")
```

## R base

```{r}
#| label: change-name-rbase
toto <- 1:3
titi <- toto
rm(toto)
```

:::

##### Reduce Boolean Series

The `all()` and `any()` methods can be used to check if all or any values in a vector evaluate to TRUE for some expression.

::: {.panel-tabset}
## polars

```{r}
#| label: all-Series
# all(pl$Series(c(TRUE,TRUE))) doesn't work
pl$Series(c(TRUE, TRUE, NA))$all()
pl$Series(c(TRUE, TRUE, FALSE))$all()
pl$Series(c(TRUE, TRUE, TRUE))$all()
```

## R base

```{r}
#| label: all-rbase
all(c(TRUE,TRUE,NA))
all(c(TRUE,TRUE,FALSE))
all(c(TRUE,TRUE,TRUE))
```

##### Get data type of Series

The `dtype()` method can be used to get data type of `Series`.

::: {.panel-tabset}
## polars

```{r}
#| label: dtype-Series

pl$Series(letters)$dtype
pl$Series(c(1, 2))$dtype
pl$DataFrame(iris)$select("Species")$to_series()$dtype
```

## R base

```{r}
#| label: dtype-rbase
infer_type(letters)
infer_type(c(1, 2))
infer_type(iris$Species)
```

:::

::: {.callout-tip}
Polars is strongly typed. `print(ls(pl$dtypes))` returns the full list of valid Polars types. Caution, some type names differ from what they are called in R base. See below!
:::

::: {.panel-tabset}
## polars

```{r}
#| label: dtype-examples-Series
pl$Series(c("x","y","z"))$dtype
pl$Series(c(1, 2, 3))$dtype
pl$Series(c(1:3))$dtype
pl$Series(c(TRUE,FALSE))$dtype
pl$DataFrame(iris)$select("Species")$to_series()$dtype
pl$Series(Sys.Date())$dtype
pl$Series(c(0,1))$dtype
```

## R base

```{r}
#| label: dtype-examples-rbase
typeof(c("x","y","z"))
typeof(c(1, 2, 3))
typeof(c(1:3))
typeof(c(TRUE,FALSE))
typeof(iris$Species)
typeof(Sys.Date())
```

:::

To summarise the main types between Polars and R:

| Polars      | R Base    |
|-------------|-----------|
| Utf8        | character |
| Float64     | double    |
| Int32       | integer   |
| Boolean     | logical   |
| Categorical | Factor    |
| Date        | Date      |



#### On DataFrames

```{r}
#| label: useful-methods-DataFrame
# To get one column by name as series 
pl$DataFrame(a = 1:4)$to_series()
# To create a new DataFrame that shows the null counts per column
x = mtcars
x[1, 2:3] = NA
pl$DataFrame(x)$null_count()
# To get a slice
pl$DataFrame(mtcars)$slice(2, 4)
# To sort
df$sort("mpg")
# To structure
df = pl$DataFrame(a = 1:5, b = c("one", "two", "three", "four", "five"))
s = df$to_struct()
s
s$to_r() # to r list
# To drop duplicate rows from this dataframe. 
```

### List of methods to apply to Series

To learn more about the methods to be applied to the `Series`, see [this page](https://rpolars.github.io/reference/Series_class/).

```{r}
#| label: list-methods-series
# See all exported methods for Series
ls(polars:::Series)
# See all private methods for Series (not intended for regular use)
ls(polars:::.pr$Series)
```

### List of methods to apply to DataFrame

To learn more about the methods to be applied to the `DataFrames`, see [this page](https://rpolars.github.io/reference/DataFrame_class/).

```{r}
#| label: list-methods-dataframes
# See all exported methods for DataFrame
ls(polars:::DataFrame)
# See all private methods for DataFrame (not intended for regular use)
ls(polars:::.pr$DataFrame)
```