# Data manipulation

```{r}
#| label: load-packages-data-manipulation
#| code-fold: true
#| message: false
#| warning: false
#| results: 'hide'
library(polars)
library(dplyr)
library(data.table)
library(arrow)
iris_dt <- as.data.table(iris)

# Creation of mydf DataFrame 
mydf <- pl$DataFrame(
  col1 = pl$Series(1:3),
  col2 = pl$Series(c("a","b","c"))
)
```

## Methods

The added value of Polars consists in the `methods`. Those powerful methods are accessed using the `$` operator.  

- For `Series`, see [this section](#list-of-methods-to-apply-to-series) for the methods available in {polars}.
- For `DataFrames`, see [this section](#list-of-methods-to-apply-to-dataframe) for the methods available in {polars}.

Some examples with `Series`:

```{r}
#| label: series-manipulation-method
# To get a sum
mynumbers_serie$sum()
# To sort in descending order
mynumbers_serie$sort(reverse = TRUE)
```

Some examples with `DataFrame`:

```{r}
#| label: dataframe-manipulation-method
# To get a character vector of column names
mydf$columns
# To get dimensions of DataFrame
mydf$shape
# We can mix standard R functions and methods
length(mydf$columns)
```

Polars includes a very useful chaining method in data manipulation operations. From this point of view, Polars is more like dplyr and data.table.
This is how the chaining method is defined in the official documentation:

> In polars our method chaining syntax takes the form `object$m1()$m2()`, where object is our data `object`, and `m1()` and `m2()` are appropriate methods, like subsetting or aggregation expressions.

Let's see an example with the iris dataset:

::: {.panel-tabset}
## polars

```{r}
#| label: chaining-polars
pl$DataFrame(iris)$groupby(
  "Species")$median()  
```

## R base

```{r}
#| label: aggregate-rbase
aggregate(. ~ Species, iris, median)
```

## dplyr

```{r}
#| label: chaining-dplyr
iris |>
  group_by(Species) |>
  summarise(across(everything(),median))
```

## data.table

```{r}
#| label: chaining-datatable
iris_dt[, lapply(.SD, median), by = Species]
```

:::

::: {.callout-tip}
In the Polars code used above, you will notice that we have introduced line breaks. We could have written the whole code on the same line but for the sake of readability I prefer to separate the methods used by line breaks.
:::

## Common data manipulation methods

### Conversion between Series/DataFrames and vector/data.frames

#### From vector/data.frames to Series/DataFrames

These conversions have already been seen earlier in this book.

```{r}
#| label: conversion-to-series-dataframes
# To convert vector to Polars Series
myvector <- pl$Series(c("a","b","c"))
# To convert data.frames to DataFrames
iris_polars <- pl$DataFrame(iris)
```

#### From Series/DataFrames to vector/data.frames

Here, we can use `to_r()` and `to_data_frame()` methods.

```{r}
#| label: conversion-tor-dataframes
# To convert Polars Series to vector or list
myletters_serie$to_r()
# To convert DataFrames to data.frames
mydf$to_data_frame()
```

### Some initial informations on a DataFrame

#### First overview of a DataFrame

Here is a list of instructions that I frequently use to quickly get information about a `DataFrame`.

```{r}
#| label: informations-methods
# To get the schema (= a named list)
mydf$schema
# To get column types as strings. 
mydf$dtype_strings()
# To get an estimation of the total allocated size (in Bytes)
mydf$estimated_size()
# To get the first n rows
mydf$head(2)
# To get the dimensions
mydf$shape
```

::: {.callout-caution}
Polars API contains useful methods for quickly describing a `DataFrame` - [describe](https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.describe.html) and [glimpse](https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.glimpse.html#) that has not yet been implemented (end of May 2023).
:::

#### Count NA over columns in a DataFrame

The `null_count()` method can be used to count NA values of a DataFrame.

::: {.panel-tabset}
## polars

```{r}
#| label: null-count-polars
mydfNA <- pl$DataFrame(
  colA = pl$Series(c("a",NA,"c")),
  colB = pl$Series(c("d",NA,NA)))
mydfNA$null_count()
```

## R base

```{r}
#| label: sapply-NA-rbase
mydfNA <- data.frame(
  colA = c("a",NA,"c"),
  colB = c("d",NA,NA))
sapply(mydfNA, function(x) sum(is.na(x)))
```

## dplyr

```{r}
#| label: count-NA-dplyr
mydfNA %>%
  summarise(across(everything(), ~sum(is.na(.))))
```

## data.table

```{r}
#| label: count-NA-datatable
mydfNA_dt <- as.data.table(mydfNA)
mydfNA_dt[, lapply(.SD, function(x) sum(is.na(x))), .SDcols = names(mydfNA_dt)]
```

:::

### Method filter

The `filter()` method is used to filter the rows of a DataFrame. It must be used with the `col()` method which allows to designate the columns on which the filter condition will be applied.

::: {.panel-tabset}
## polars

```{r}
#| label: filter-polars
pl$DataFrame(iris)$filter(
  pl$col("Petal.Length") > 6 & pl$col("Petal.Width") < 2)
```

## R base

```{r}
#| label: filter-rbase
iris[iris$Petal.Length > 6 & iris$Petal.Width < 2,] # here don't forget the comma
```

## dplyr

```{r}
#| label: filter-dplyr
iris |>
  filter(Petal.Length > 6 & Petal.Width < 2) 
```

## data.table

```{r}
#| label: filter-datatable
iris_dt[Petal.Length > 6 & Petal.Width < 2]
```

:::

### Method select

The `select()` method is used to filter the rows of a DataFrame. It must be used with the `col()` method which allows to designate the columns to be selected.

::: {.panel-tabset}
## polars

```{r}
#| label: select-polars
pl$DataFrame(iris)$select(
  pl$col(c("Petal.Length","Petal.Width"))
)$head(3) # display the first 3 lines
```

## R base

```{r}
#| label: select-rbase
iris[1:3,c("Petal.Length","Petal.Width")] 
```

## dplyr

```{r}
#| label: select-dplyr
iris |>
  select(Petal.Length,Petal.Width) |>
  head(3)
```

## data.table

```{r}
#| label: select-datatable
iris_dt[1:3,.(Petal.Length,Petal.Width)]
```

:::

::: {.callout-note}
With Polars if you want to obtain a result in an R data.frame, you can simply add the method `to_data_frame()` at the end of the method chaining.
:::

Similar to the dplyr package, the select() method can also be used to modify existing data. However, the result will exclude any columns that were not specified in the expression.

For example, if we want to get in the data.frame iris the `Petal.Length` column rounded without decimals.

```{r}
#| label: select-round-select-polars
pl$DataFrame(iris)$select(
  pl$col("Petal.Length")$round(decimals = 0)
)$head(3) # display the first 3 lines
```

The problem here is that we would like to keep all the iris columns and not just `Petal.Length`.

Again, let's look at the official documentation:

> To modify or add some columns—whilst preserving all others in the dataset—it is therefore better to use the `with_columns()` method. 

::: {.panel-tabset}
## polars

```{r}
#| label: select-round-with_column-polars
pl$DataFrame(iris)$with_columns(
  pl$col("Petal.Length")$round(decimals = 0)
)$head(3) # display the first 3 lines
```

## R base

```{r}
#| label: select-round-rbase
iris$Petal.Length <- round(iris$Petal.Length, digits = 0)
iris[1:3,]
```

## dplyr

```{r}
#| label: select-round-dplyr
data(iris)
iris |>
  mutate(Petal.Length = round(Petal.Length,0)) |>
  head(3)
```

## data.table

```{r}
#| label: select-round-datatable
iris_dt[,Petal.Length := round(Petal.Length, digits = 0)]
iris_dt[1:3,]
```

:::

If you want to add a column to a data.frame, you use the same syntax as above with `with_columns()`. Simply use the `alias()` method to specify the name of the newly created column.

```{r}
#| label: select-round-alias-polars
pl$DataFrame(iris)$with_columns(
  pl$col("Petal.Length")$round(decimals = 0)$alias("Petal.Length.rounded")
)$head(3) # display the first 3 lines
```

### Methods agg and group_by

Another frequently used data manipulation is the aggregation of data by group.
To do this, we indicate in the `group_by()` method which column will be used to group the data.frame. And the `agg()` method which specifies the expression to aggregate.

::: {.panel-tabset}
## polars

```{r}
#| label: agg-polars
pl$DataFrame(iris)$groupby(
  "Species"
)$agg(
  pl$col(c("Petal.Length","Petal.Width"))$sum()
)
```

## R base

```{r}
#| label: aggregate-cbind-rbase
aggregate(cbind(Petal.Length, Petal.Width) ~ Species, data = iris, FUN = sum)
```

## dplyr

```{r}
#| label: summarise-dplyr
data(iris)
iris |>
  group_by(Species) |>
  summarise(across(c(Petal.Length, Petal.Width), sum)) 
```

## data.table

```{r}
#| label: summarise-datatable
iris_dt <- as.data.table(iris)
iris_dt[, .(Petal.Length = sum(Petal.Length), Petal.Width = sum(Petal.Width)), by = Species]
```

:::

### Method join

To perform joins, the `join()` method must be used.

::: {.panel-tabset}
## polars

```{r}
#| label: join-polars
# First, creation of colors_species Polars DataFrame
colors <- pl$DataFrame(
  Surname = pl$Series(c("toto","titi","tata")),
  Color = pl$Series(c("blue","red","yellow"))
)
values <- pl$DataFrame(
  Surname = pl$Series(c("toto","titi","tata")),
  value = pl$Series(c(10,20,30))
)
# Let's join !
colors$join(
  other = values,
  on = "Surname",
  how = "left"
)
```

## R base

```{r}
#| label: merge-rbase
colors <- data.frame(
  Surname = c("toto","titi","tata"),
  Color = c("blue","red","yellow")
)
values <- data.frame(
  Surname = c("toto","titi","tata"),
  value = c(10,20,30)
)
merge(colors, values, by = "Surname", all.x = TRUE)
```

## dplyr

```{r}
#| label: join-dplyr
colors |>
  left_join(values,
            by = "Surname") 
```

## data.table

```{r}
#| label: join-datatable
merge(as.data.table(colors), 
      as.data.table(values), 
      by = "Surname", all.x = TRUE)
```

:::

### Others useful methods

#### On Series

##### Change name of Series 

The `alias()` method is very useful especially in method chaining operation.  
With R base, the syntax is longer.

::: {.panel-tabset}
## polars

```{r}
#| label: change-name-Series
pl$Series(1:3, name = "toto")$alias("titi")
```

## R base

```{r}
#| label: change-name-rbase
toto <- 1:3
titi <- toto
rm(toto)
```

:::

##### Reduce Boolean Series

The `all()` and `any()` methods can be used to check if all or any values in a vector evaluate to TRUE for some expression.

::: {.panel-tabset}
## polars

```{r}
#| label: all-Series
# all(pl$Series(c(TRUE,TRUE))) doesn't work
pl$Series(c(TRUE, TRUE, NA))$all()
pl$Series(c(TRUE, TRUE, FALSE))$all()
pl$Series(c(TRUE, TRUE, TRUE))$all()
```

## R base

```{r}
#| label: all-rbase
all(c(TRUE,TRUE,NA))
all(c(TRUE,TRUE,FALSE))
all(c(TRUE,TRUE,TRUE))
```
:::

##### Get data type of Series

The `dtype()` method can be used to get data type of `Series`.

::: {.panel-tabset}
## polars

```{r}
#| label: dtype-Series

pl$Series(letters)$dtype
pl$Series(c(1, 2))$dtype
pl$DataFrame(iris)$select("Species")$to_series()$dtype
```

## R base

```{r}
#| label: dtype-rbase
infer_type(letters)
infer_type(c(1, 2))
infer_type(iris$Species)
```

:::

::: {.callout-tip}
Polars is strongly typed. `print(ls(pl$dtypes))` returns the full list of valid Polars types. Caution, some type names differ from what they are called in R base. See below!
:::

::: {.panel-tabset}
## polars

```{r}
#| label: dtype-examples-Series
pl$Series(c("x","y","z"))$dtype
pl$Series(c(1, 2, 3))$dtype
pl$Series(c(1:3))$dtype
pl$Series(c(TRUE,FALSE))$dtype
pl$DataFrame(iris)$select("Species")$to_series()$dtype
pl$Series(Sys.Date())$dtype
pl$Series(c(0,1))$dtype
```

## R base

```{r}
#| label: dtype-examples-rbase
typeof(c("x","y","z"))
typeof(c(1, 2, 3))
typeof(c(1:3))
typeof(c(TRUE,FALSE))
typeof(iris$Species)
typeof(Sys.Date())
```

:::

To summarise the main types between Polars and R:

| Polars      | R Base    |
|-------------|-----------|
| Utf8        | character |
| Float64     | double    |
| Int32       | integer   |
| Boolean     | logical   |
| Categorical | Factor    |
| Date        | Date      |

To learn more about Data types in Polars, see [here](https://pola-rs.github.io/polars-book/user-guide/concepts/data-types/). 

##### Cast

The `cast()` method can be used to convert the data types of a column to a new one.  
With R base, the syntax is longer.

```{r}
#| label: cast-polars
pl$DataFrame(iris)$with_columns(
  pl$col("Petal.Length")$cast(pl$Int64), # The "Petal.Length" column is converted into integers
  pl$col("Species")$cast(pl$Utf8) # The "Species" column is converted into strings
  )$schema
```

::: {.callout-tip}
When working with very large tables we can **Reduce the memory footprint** by modifying the number of bits allocated to an element. ⚠️
:::

For example, the example below illustrates how converting Float64 to Float8 reduces memory usage:

```{r}
pl$DataFrame(iris)$estimated_size()

#| label: reduce-footprint-polars
pl$DataFrame(iris)$with_columns(
  pl$col("Petal.Length")$cast(pl$Float32), 
  pl$col("Petal.Width")$cast(pl$Float32), 
  pl$col("Sepal.Length")$cast(pl$Float32), 
  pl$col("Sepal.Width")$cast(pl$Float32)
  )$estimated_size()
```
⚠️ When performing downcasting, it is crucial to ensure that the chosen number of bits is sufficient to accommodate the largest and smallest numbers in the column.  

A quick reminder:

| Type    	| Range                      	| Accuracy                	|
|---------	|----------------------------	|-------------------------	|
| Int8    	| -128 to +127               	|                         	|
| Int16   	| -32768 to +32767           	|                         	|
| Int32   	| -2147483648 to +2147483647 	|                         	|
| Int64   	| –2E63 to –2E63-1           	|                         	|
| Float32 	| -3.4E+38 to +3.4E+38       	| about 7 decimal digits  	|
| Float64 	| -1.7E+308 to +1.7E+308     	| about 16 decimal digits 	|




##### Check if Series is numeric

The `is_numeric()` method can be used to check if `Series` is numeric.  
Note that unlike R base, there is no method to check if a Series is character (in this case, its type is anyway Utf8).  

::: {.panel-tabset}
## polars

```{r}
#| label: isnumeric-Series
pl$Series(1:4)$is_numeric()
pl$Series(c("a", "b", "c"))$is_numeric()
```

## R base

```{r}
#| label: isnumeric-rbase
is.numeric(1:4)
is.numeric(c("a","b","c"))
```
:::

##### Check if Series is sorted

The `is_sorted()` method can be used to check if `Series` is sorted.  
Note that R base provides `is.unsorted()` which returns the opposite boolean to `is_sorted()` of Polars.

::: {.panel-tabset}
## polars

```{r}
#| label: issorted-Series
pl$Series(1:4)$is_sorted()
pl$Series(c(1,3,2))$is_sorted()
```

## R base

```{r}
#| label: isunsorted-rbase
is.unsorted(1:4)
is.unsorted(c(1,3,2))
```
:::

##### Get length of a Series

The `len()` method can be used to get the length of a `Series`.  

::: {.panel-tabset}
## polars

```{r}
#| label: len-Series
pl$Series(1:4)$len()
```

## R base

```{r}
#| label: length-rbase
length(1:4)
```
:::

##### Check if Series are equal

The `series_equal()` method can be used to check if a `Series` is equal with another `Series`.

::: {.callout-tip}
Caution, if two series are identical but one is named and the other is not then `series_equal()` returns FALSE.
:::

::: {.panel-tabset}
## polars

```{r}
#| label: series-equal-Series
pl$Series(1:4)$series_equal(pl$Series(1:4))
pl$Series(1:4,name = "toto")$series_equal(pl$Series(1:4))
```

## R base

```{r}
#| label: identical-rbase
identical(1:4,1:4)
```
:::

##### Convert Series to Polars DataFrame

The `to_frame()` method can be used to convert a `Series` to a `DataFrame`.  
In this case, a `DataFrame` with only one column will be created. If the `Series` is initially named then the column of the `DataFrame` will be named as such.

```{r}
#| label: to-frame-Series
pl$Series(1:3, "toto")$to_frame()
```

##### Get value Counts of a Series

The `value_counts()` method can be used to get a value counts of a `Series`.  

::: {.panel-tabset}
## polars

```{r}
#| label: value-counts-Series
pl$Series(iris$Species)$value_counts()
```

## R base

```{r}
#| label: table-rbase
table(iris$Species)
```

## dplyr

```{r}
#| label: count-dplyr
iris |>
  count(Species)
```

## data.table

```{r}
#| label: value-counts-datatable
iris_dt[, .N, by = Species]
```
:::

#### On DataFrames

##### Get Series from DataFrame

The `to_series()` method can be used to get one column from `DataFrame` as `Series`.  

::: {.panel-tabset}
## polars

```{r}
#| label: to-series-Series
pl$DataFrame(iris)$select(pl$col("Petal.Length"))$to_series()
```

## R base

```{r}
#| label: tovector-rbase
iris$Species
```

## dplyr

```{r}
#| label: pull-dplyr
iris |>
  pull(Species)
```

## data.table

```{r}
#| label: tovector-datatable
iris_dt[, c(Species)]
```
:::

##### Get a slice of a DataFrame

The `to_series()` method can be used to get a slice of a `DataFrame`.

::: {.callout-important}
With Polars, numeric default is 0! Thus the equivalent to `slice(1,3)` with Polars will be `2:4` in R Base and data.table and `slice(1,4)` with dplyr.
:::

::: {.panel-tabset}
## polars

```{r}
#| label: slice-Series
pl$DataFrame(iris)$slice(1,3)
```

## R base

```{r}
#| label: slice-rbase
iris[2:4,]
```

## dplyr

```{r}
#| label: slice-dplyr
iris |>
  slice(2:4)
```

## data.table

```{r}
#| label: slice-datatable
iris_dt[2:4,]
```
:::

##### Sort a DataFrame

The `sort()` method can be used to sort a `DataFrame`.

::: {.panel-tabset}
## polars

```{r}
#| label: sort-dataframe-polars
# Sort by one column
pl$DataFrame(iris
  )$sort("Species"
  )$head(3)
# Sort by two columns
pl$DataFrame(iris
  )$sort(c("Species","Petal.Length")
  )$head(3)
# Sort by two columns one in a decreasing manner and the other in an increasing manner
pl$DataFrame(iris
  )$sort(c("Species","Petal.Length"), descending = c(TRUE,FALSE)
  )$head(3)
```

## R base

```{r}
#| label: sort-dataframe-rbase
# Sort by one column
iris[order(iris$Species),][1:3,]
# Sort by two columns
iris[order(iris$Species,iris$Petal.Length),][1:3,]
# Sort by two columns one in a decreasing manner and the other in an increasing manner
iris[order(rev(iris$Species),iris$Petal.Length),][1:3,]
```

## dplyr

```{r}
#| label: sort-dataframe-dplyr
# Sort by one column
iris |>
  arrange(Species) |>
  head(3)
# Sort by two columns
iris |>
  arrange(Species, Petal.Length) |>
  head(3)
# Sort by two columns one in a decreasing manner and the other in an increasing manner
iris |>
  arrange(desc(Species), Petal.Length) |>
  head(3)
```

## data.table

```{r}
#| label: sort-dataframe-datatable
# Sort by one column
iris_dt[order(Species)][1:3,]
# Sort by two columns
iris_dt[order(Species,Petal.Length)][1:3,]
# Sort by two columns one in a decreasing manner and the other in an increasing manner
iris_dt[order(-Species,Petal.Length)][1:3,]
```
:::

##### Get a structure from a DataFrame

The `to_struct()` method can be used to get a structure from a `DataFrame`.  


```{r}
#| label: to_struct-dataframe-polars
mystruc <- mydf$to_struct()
mystruc
```

`to_struct()` returns a `Series` which can be converted to a R list with `to_r` method.

```{r}
#| label: to_struct-to-r
mylist <- mystruc$to_r()
mylist
```
`
mylist is now a list where each element is a column of the initial DataFrame.

With `to_frame()` and `unnest()` methods, we can reconstruct the original DataFrame:

```{r}
back_df <- mystruc$to_frame()$unnest()
back_df
```


### List of methods to apply to Series

To learn more about the methods to be applied to the `Series`, see [this page](https://rpolars.github.io/reference/Series_class/).

```{r}
#| label: list-methods-series
# See all exported methods for Series
ls(polars:::Series)
# See all private methods for Series (not intended for regular use)
ls(polars:::.pr$Series)
```

### List of methods to apply to DataFrame

To learn more about the methods to be applied to the `DataFrames`, see [this page](https://rpolars.github.io/reference/DataFrame_class/).

```{r}
#| label: list-methods-dataframes
# See all exported methods for DataFrame
ls(polars:::DataFrame)
# See all private methods for DataFrame (not intended for regular use)
ls(polars:::.pr$DataFrame)
```