# Benchmarking

{{< include content/benchmarking/_setup_benchmarking.qmd >}}

{{< include content/benchmarking/_from_csv.qmd >}}

{{< include content/benchmarking/_from_unique_parquet.qmd >}}

{{< include content/benchmarking/_from_partitioned_parquet.qmd >}}

{{< include content/benchmarking/_from_duckdb.qmd >}}












PLAN :
1. A partir d'un fichier csv, comparer les performances d'une requête avec :
  i. R Base
  ii. dplyr
  iii. data.table
  iv. polars
2. A partir d'un fichier parquet unique, comparer : 
  i. dplyr
  ii. polars
3. A partir d'un fichier parquet partitionné, comparer : 
  i. dplyr
  ii. polars
4. La même comparaison à partir d'un fichier duckdb
  i. requête sql
  ii. dbplyr
  iii. polars


## Polars to DuckDB

DuckDB can natively query Polars DataFrames by referring to the name of Polars DataFrames as they exist in the current scope.


```{r}
con <- dbConnect(duckdb::duckdb(),
                 "Datasets/data.duckdb")
# Fonctionne
duckdb::dbWriteTable(con,
                     "iris_table",
                     iris,
                     overwrite = TRUE)
# Fonctionne
duckdb::dbWriteTable(con,
                     "mtcars_table",
                     mtcars,
                     overwrite = TRUE)
# Ne fonctionne pas
duckdb::dbWriteTable(con,
                     "iris_pl_table",
                     pl$DataFrame("iris"),
                     overwrite = TRUE)
dbListTables(con)
dbGetQuery(con, "SELECT * FROM iris_table WHERE SPECIES == 'setosa'")
dbExecute(con, "CREATE TABLE items(item VARCHAR, value DECIMAL(10,2), count INTEGER)")
dbExecute(con, "INSERT INTO items VALUES ('jeans', 20.0, 1), ('hammer', 42.2, 2)")
res <- dbGetQuery(con, "SELECT * FROM items")
print(res)
```


